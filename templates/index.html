<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Two Friends Chat with Live Preview</title>
<style>
  body { font-family: Arial, sans-serif; margin: 0; padding-bottom: 70px; background: #f5f5f5;}
  #chat-box {
    padding: 10px;
    overflow-y: auto;
    height: calc(100vh - 70px);
    display: flex;
    flex-direction: column;
    justify-content: flex-end;
  }
  .message {
    max-width: 60%;
    padding: 8px 12px;
    margin: 5px;
    border-radius: 10px;
    word-wrap: break-word;
    line-height: 1.3;
    font-size: 16px;
  }
  .sender {
    background: #d1e7ff;
    align-self: flex-end;
    text-align: right;
  }
  .receiver {
    background: #c1f7d1;
    align-self: flex-start;
    text-align: left;
  }
  .preview {
    opacity: 0.6;
    font-style: italic;
  }
  #input-area {
    position: fixed;
    bottom: 0; left: 0; width: 100%;
    background: white;
    padding: 10px;
    display: flex;
    gap: 5px;
    box-shadow: 0 -2px 5px rgba(0,0,0,0.1);
  }
  input, select, button {
    padding: 8px;
    font-size: 16px;
  }
  input { flex: 1;}
</style>
</head>
<body>

<div id="chat-box"></div>

<div id="input-area">
  <select id="sender">
    <option value="friend1">Friend 1</option>
    <option value="friend2">Friend 2</option>
  </select>
  <input type="text" id="message" placeholder="Type a message..." autocomplete="off"/>
  <button id="send-btn">Send</button>
</div>

<!-- Socket.IO client -->
<script src="https://cdn.socket.io/4.6.1/socket.io.min.js"></script>
<script>
  const socket = io(); // connects to same origin
  let currentUser = document.getElementById("sender").value;

  // register on connect
  function register() {
    currentUser = document.getElementById("sender").value;
    socket.emit('register', { username: currentUser });
    // clear input and local preview UI
    document.getElementById("message").value = "";
    renderChat([]); // we will fetch history via socket 'history' event or via fetch
  }

  // Local in-memory messages for display (mirrors server)
  let messages = [];
  let currentPreview = ""; // preview from other user

  function renderChat(extraMsgs=[]) {
    const chatBox = document.getElementById("chat-box");
    chatBox.innerHTML = "";
    const all = messages.concat(extraMsgs);
    all.sort((a,b) => a.timestamp - b.timestamp);

    all.forEach(msg => {
      const div = document.createElement("div");
      div.classList.add("message");
      if(msg.sender === currentUser) {
        div.classList.add("sender");
      } else {
        div.classList.add("receiver");
      }
      div.textContent = msg.text;
      chatBox.appendChild(div);
    });

    // show preview from other user
    const otherUser = currentUser === "friend1" ? "friend2" : "friend1";
    if(currentPreview && currentPreview.trim() !== "") {
      const previewDiv = document.createElement("div");
      previewDiv.classList.add("message", "receiver", "preview");
      previewDiv.textContent = currentPreview;
      chatBox.appendChild(previewDiv);
    }

    chatBox.scrollTop = chatBox.scrollHeight;
  }

  // receive history from server
  socket.on('history', (data) => {
    messages = data || [];
    renderChat();
  });

  // receive a new message
  socket.on('new_message', (msg) => {
    messages.push(msg);
    renderChat();
  });

  // receive preview/typing from other user
  socket.on('preview', (data) => {
    // data: { from: 'friend1', text: '...' }
    const from = data.from;
    const text = data.text || "";
    const otherUser = currentUser === "friend1" ? "friend2" : "friend1";
    // only accept preview if it's from the other user
    if(from === otherUser) {
      currentPreview = text;
      renderChat();
    }
  });

  function sendMessage() {
    const sender = document.getElementById("sender").value;
    const receiver = sender === "friend1" ? "friend2" : "friend1";
    const messageInput = document.getElementById("message");
    const text = messageInput.value.trim();
    if(!text) return;
    socket.emit('send_message', { sender, receiver, text });
    messageInput.value = "";
    // also clear typing / preview locally and notify server
    socket.emit('typing', { sender, receiver, text: '' });
  }

  // typing preview emit
  let typingTimer = null;
  function previewMessage() {
    const sender = document.getElementById("sender").value;
    const receiver = sender === "friend1" ? "friend2" : "friend1";
    const messageInput = document.getElementById("message");
    const text = messageInput.value;

    socket.emit('typing', { sender, receiver, text });

    // optional: debounce rendering locally
    if(typingTimer) clearTimeout(typingTimer);
    typingTimer = setTimeout(() => {
      // no-op; server pushes preview back to other user
    }, 200);
  }

  // UI events
  document.getElementById("send-btn").addEventListener("click", sendMessage);
  document.getElementById("message").addEventListener("input", previewMessage);
  document.getElementById("message").addEventListener("keydown", e => {
    if(e.key === "Enter") {
      e.preventDefault();
      sendMessage();
    }
  });
  document.getElementById("sender").addEventListener("change", () => {
    // change current user, register again
    register();
  });

  // when page loads, register
  window.addEventListener('load', () => {
    register();
  });

  // optional: also listen for manual history fetch (if needed)
  async function fetchHistory() {
    const res = await fetch('/history/' + currentUser);
    const data = await res.json();
    messages = data || [];
    renderChat();
  }
</script>

</body>
</html>
